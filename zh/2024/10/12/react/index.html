<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端八股文--React篇 | haoqi</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="前端八股文，React">
    
    <link rel="preload" href="/assets/css/0.styles.527ebebb.css" as="style"><link rel="preload" href="/assets/js/app.216c6cc3.js" as="script"><link rel="preload" href="/assets/js/4.ca613f77.js" as="script"><link rel="preload" href="/assets/js/1.d3222c82.js" as="script"><link rel="preload" href="/assets/js/20.efced8ed.js" as="script"><link rel="prefetch" href="/assets/js/11.0647c11b.js"><link rel="prefetch" href="/assets/js/12.606d7da7.js"><link rel="prefetch" href="/assets/js/13.f0c2774a.js"><link rel="prefetch" href="/assets/js/14.473b884d.js"><link rel="prefetch" href="/assets/js/15.9b42d14e.js"><link rel="prefetch" href="/assets/js/16.0877f871.js"><link rel="prefetch" href="/assets/js/17.fadd1e9e.js"><link rel="prefetch" href="/assets/js/18.a9466d80.js"><link rel="prefetch" href="/assets/js/19.560ed21f.js"><link rel="prefetch" href="/assets/js/2.e3b571d8.js"><link rel="prefetch" href="/assets/js/21.cebb34e0.js"><link rel="prefetch" href="/assets/js/22.f25242c3.js"><link rel="prefetch" href="/assets/js/23.b32c6bde.js"><link rel="prefetch" href="/assets/js/24.dddd19ea.js"><link rel="prefetch" href="/assets/js/25.957a261c.js"><link rel="prefetch" href="/assets/js/26.38b154a1.js"><link rel="prefetch" href="/assets/js/27.adc76e58.js"><link rel="prefetch" href="/assets/js/28.1a49449e.js"><link rel="prefetch" href="/assets/js/29.11195800.js"><link rel="prefetch" href="/assets/js/3.28814dad.js"><link rel="prefetch" href="/assets/js/30.e149e949.js"><link rel="prefetch" href="/assets/js/31.762a0c07.js"><link rel="prefetch" href="/assets/js/32.f87d3c4c.js"><link rel="prefetch" href="/assets/js/33.bc2d21a8.js"><link rel="prefetch" href="/assets/js/34.83d27607.js"><link rel="prefetch" href="/assets/js/35.212a6ba6.js"><link rel="prefetch" href="/assets/js/36.2eee53c0.js"><link rel="prefetch" href="/assets/js/37.d1f9ffce.js"><link rel="prefetch" href="/assets/js/38.804b3b4b.js"><link rel="prefetch" href="/assets/js/39.b4fc1c6d.js"><link rel="prefetch" href="/assets/js/40.9b85e78f.js"><link rel="prefetch" href="/assets/js/41.e99546fa.js"><link rel="prefetch" href="/assets/js/42.df678aa4.js"><link rel="prefetch" href="/assets/js/43.fd6f0dbd.js"><link rel="prefetch" href="/assets/js/44.772831e6.js"><link rel="prefetch" href="/assets/js/45.f96a229a.js"><link rel="prefetch" href="/assets/js/46.3cda7a04.js"><link rel="prefetch" href="/assets/js/47.eb592fa3.js"><link rel="prefetch" href="/assets/js/48.78361b86.js"><link rel="prefetch" href="/assets/js/49.08e2e053.js"><link rel="prefetch" href="/assets/js/5.1c0e5281.js"><link rel="prefetch" href="/assets/js/50.98aa2588.js"><link rel="prefetch" href="/assets/js/6.0747b09a.js"><link rel="prefetch" href="/assets/js/7.c862f1b4.js"><link rel="prefetch" href="/assets/js/8.e482b566.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.33162b08.js">
    <link rel="stylesheet" href="/assets/css/0.styles.527ebebb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">haoqi </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/zh/" class="nav-link router-link-active">博客</a></li><li class="nav-item"><a href="/tag/算法训练营/" class="nav-link">算法</a></li><li class="nav-item"><a href="https://github.com/fullyouth" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">haoqi </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/zh/" class="nav-link router-link-active">博客</a></li><li class="mobile-nav-item"><a href="/tag/算法训练营/" class="nav-link">算法</a></li><li class="mobile-nav-item"><a href="https://github.com/fullyouth" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        前端八股文--React篇
      </h1> <div class="post-meta"><!----> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2024-10-12T00:00:00.000Z">
      2024-10-12 周6
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/前端八股文" data-v-42ccfcd5><span data-v-42ccfcd5>前端八股文</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/React" data-v-42ccfcd5><span data-v-42ccfcd5>React</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h1 id="react-知识大纲"><a href="#react-知识大纲" class="header-anchor">#</a> React 知识大纲</h1> <h2 id="一、组件基础"><a href="#一、组件基础" class="header-anchor">#</a> 一、组件基础</h2> <h3 id="_1-1-react-事件机制"><a href="#_1-1-react-事件机制" class="header-anchor">#</a> 1.1 React 事件机制</h3> <p><img src="/assets/img/React-event.3f9c15e4.png" alt="image"></p> <h3 id="_1-2-react-高阶组件、render-props、hooks-的区别及迭代原因"><a href="#_1-2-react-高阶组件、render-props、hooks-的区别及迭代原因" class="header-anchor">#</a> 1.2 React 高阶组件、Render props、hooks 的区别及迭代原因</h3> <p><a href="https://github.com/z-memo/interview/issues/219" target="_blank" rel="noopener noreferrer">https://github.com/z-memo/interview/issues/219<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_1-3-对-react-fiber-的理解及解决的问题"><a href="#_1-3-对-react-fiber-的理解及解决的问题" class="header-anchor">#</a> 1.3 对 React-Fiber 的理解及解决的问题</h3> <h3 id="_1-4-react-高阶组件的定义、与普通组件的区别及适用场景"><a href="#_1-4-react-高阶组件的定义、与普通组件的区别及适用场景" class="header-anchor">#</a> 1.4 React 高阶组件的定义、与普通组件的区别及适用场景</h3> <h3 id="_1-5-触发-react-重新渲染的方法及重新渲染时-render-的作用"><a href="#_1-5-触发-react-重新渲染的方法及重新渲染时-render-的作用" class="header-anchor">#</a> 1.5 触发 React 重新渲染的方法及重新渲染时 render 的作用</h3> <h3 id="_1-6-有状态组件和无状态组件的理解与使用场景"><a href="#_1-6-有状态组件和无状态组件的理解与使用场景" class="header-anchor">#</a> 1.6 有状态组件和无状态组件的理解与使用场景</h3> <p><strong>有状态组件</strong><br>
定义：在组件内部能够维护和管理状态（state）的组件</p> <ul><li>需要处理用户交互</li> <li>复杂的业务逻辑和状态管理</li></ul> <p><strong>无状态组件</strong><br>
定义：组件内部没有自己的状态（它只接收外部传入的属性（props），并根据这些属性来渲染输出，无状态组件是一个纯函数，对于相同的输入（即相同的属性），它总是返回相同的输出）</p> <ul><li>展示静态数据或简单的动态数据（基于传入属性）</li> <li>方便用于组合和复用</li> <li>有利于react性能优化（无状态组件是可预测的。如果组件不变，props不变，就不需要重新render）</li></ul> <h3 id="_1-7-react-中的受控组件和非控组件"><a href="#_1-7-react-中的受控组件和非控组件" class="header-anchor">#</a> 1.7 React 中的受控组件和非控组件</h3> <h3 id="_1-8-类组件与函数组件的异同"><a href="#_1-8-类组件与函数组件的异同" class="header-anchor">#</a> 1.8 类组件与函数组件的异同</h3> <h3 id="_1-9-react-的事件与普通-html-事件的不同"><a href="#_1-9-react-的事件与普通-html-事件的不同" class="header-anchor">#</a> 1.9 React 的事件与普通 HTML 事件的不同</h3> <h3 id="_1-10-react-createclass-和-extends-component-的区别"><a href="#_1-10-react-createclass-和-extends-component-的区别" class="header-anchor">#</a> 1.10 React.createClass 和 extends Component 的区别</h3> <h3 id="_1-11-react-判断重新渲染组件的方式"><a href="#_1-11-react-判断重新渲染组件的方式" class="header-anchor">#</a> 1.11 React 判断重新渲染组件的方式</h3> <h3 id="_1-12-对-react-中-fragment-的理解及使用场景"><a href="#_1-12-对-react-中-fragment-的理解及使用场景" class="header-anchor">#</a> 1.12 对 React 中 Fragment 的理解及使用场景</h3> <h3 id="_1-13-react-获取组件对应的-dom-元素的方法"><a href="#_1-13-react-获取组件对应的-dom-元素的方法" class="header-anchor">#</a> 1.13 React 获取组件对应的 DOM 元素的方法</h3> <p>ref</p> <h3 id="_1-14-对-react-的插槽-portals-的理解、使用方法及场景"><a href="#_1-14-对-react-的插槽-portals-的理解、使用方法及场景" class="header-anchor">#</a> 1.14 对 React 的插槽（Portals）的理解、使用方法及场景</h3> <p>可以让一个组件的内容 “跳出” 它原本所在的组件层级，出现在页面的其他位置</p> <div class="language-js extra-class"><pre class="language-js"><code>ReactDOM<span class="token punctuation">.</span><span class="token function">createPortal</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Comp<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span>
</code></pre></div><p>主要用于弹窗浮层中</p> <h3 id="_1-15-在-react-中避免不必要-render-的方法"><a href="#_1-15-在-react-中避免不必要-render-的方法" class="header-anchor">#</a> 1.15 在 React 中避免不必要 render 的方法</h3> <h3 id="_1-16-对-react-intl-的理解及工作原理"><a href="#_1-16-对-react-intl-的理解及工作原理" class="header-anchor">#</a> 1.16 对 React-Intl 的理解及工作原理</h3> <h3 id="_1-17-对-react-context-的理解"><a href="#_1-17-对-react-context-的理解" class="header-anchor">#</a> 1.17 对 React context 的理解</h3> <h3 id="_1-18-react-中绑定-this-的其他方式"><a href="#_1-18-react-中绑定-this-的其他方式" class="header-anchor">#</a> 1.18 React 中绑定 this 的其他方式</h3> <h3 id="_1-19-react-组件中事件代理的方法及原理"><a href="#_1-19-react-组件中事件代理的方法及原理" class="header-anchor">#</a> 1.19 React 组件中事件代理的方法及原理</h3> <h3 id="_1-20-react-component-和-react-purecomponent-的区别"><a href="#_1-20-react-component-和-react-purecomponent-的区别" class="header-anchor">#</a> 1.20 React.Component 和 React.PureComponent 的区别</h3> <h3 id="_1-21-component-element-instance-之间的区别与联系"><a href="#_1-21-component-element-instance-之间的区别与联系" class="header-anchor">#</a> 1.21 Component, Element, Instance 之间的区别与联系</h3> <h3 id="_1-22-react-声明组件的方法及区别"><a href="#_1-22-react-声明组件的方法及区别" class="header-anchor">#</a> 1.22 React 声明组件的方法及区别</h3> <h3 id="_1-23-react-中在-render-访问-refs-的情况及原因"><a href="#_1-23-react-中在-render-访问-refs-的情况及原因" class="header-anchor">#</a> 1.23 React 中在 render 访问 refs 的情况及原因</h3> <h3 id="_1-24-为什么-react-不推荐优先考虑使用-context"><a href="#_1-24-为什么-react-不推荐优先考虑使用-context" class="header-anchor">#</a> 1.24 为什么 React 不推荐优先考虑使用 Context</h3> <h3 id="_1-25-react-中-refs-的作用及应用场景"><a href="#_1-25-react-中-refs-的作用及应用场景" class="header-anchor">#</a> 1.25 React 中 refs 的作用及应用场景</h3> <h3 id="_1-26-react-组件的构造函数的作用及必要性"><a href="#_1-26-react-组件的构造函数的作用及必要性" class="header-anchor">#</a> 1.26 React 组件的构造函数的作用及必要性</h3> <ul><li>继承父类React.Component,使用Super关键字</li> <li>初始化state,mounted之前的默认值</li> <li>绑定函数<code>fn.bind(this)</code></li></ul> <h3 id="_1-27-对-componentwillreceiveprops-的理解"><a href="#_1-27-对-componentwillreceiveprops-的理解" class="header-anchor">#</a> 1.27 对 componentWillReceiveProps 的理解</h3> <p><img src="/assets/img/react-lifecycle.f88599b9.jpg" alt="image"></p> <p><code>componentWillMount</code>和<code>componentWillReceiveProps</code> 已经被废弃<br>
原因：异步渲染过程中可能会因为多次调用而导致状态更新不一致</p> <p>替代方案：<code>getDerivedStateFromProps</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>initialValue<span class="token operator">!==</span> state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 可以一步获取接口数据</span>
      <span class="token comment">// 但是不能获取组件实例this</span>
       <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> props<span class="token punctuation">.</span>initialValue <span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-28-react-forwardref-的定义及作用"><a href="#_1-28-react-forwardref-的定义及作用" class="header-anchor">#</a> 1.28 React.forwardRef 的定义及作用</h3> <p>forwardRef 允许组件使用 ref 将 DOM 节点暴露给父组件</p> <p>用法：</p> <ul><li>将 DOM 节点暴露给父组件</li> <li>在多个组件中转发 ref</li> <li>暴露命令式句柄（结合useImperativeHandle）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> SomeComponent <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span>render<span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyInput <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">MyInput</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>label<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>props<span class="token punctuation">.</span>label<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不应该滥用ref，这些场景可以使用：滚动到节点、将焦点放在节点上、触发动画，以及选择文本等等<br>
如果可以将某些东西使用 props 表达，那就不应该使用 ref</p> <h2 id="二、数据管理"><a href="#二、数据管理" class="header-anchor">#</a> 二、数据管理</h2> <h3 id="_2-1-react-setstate-调用的原理"><a href="#_2-1-react-setstate-调用的原理" class="header-anchor">#</a> 2.1 React setState 调用的原理</h3> <p>一句话介绍：调用setState，更新state，从而更新UI<br>
原理：<br> <strong>异步更新</strong>： React为了提高性能，不可能更改state之后，同步更新UI，所以这是一个异步的过程
<strong>批处理</strong>： 每次调用setState，会提交一个更新state队列，在合适的时机对这些队列进行批处理</p> <h3 id="_2-2-react-setstate-调用之后的情况-同步或异步"><a href="#_2-2-react-setstate-调用之后的情况-同步或异步" class="header-anchor">#</a> 2.2 React setState 调用之后的情况（同步或异步）</h3> <p>分情况<br>
React 18 之前<br>
合成事件系统之内的是异步更新，之外是同步更新
如setTimeout，直接绑定在dom上的事件，this.setState回调函数，都是同步更新</p> <p>React 18 之后<br>
实现了自动批处理，setTimeout，直接绑定在dom上的事件，</p> <h3 id="_2-3-react-组件中-this-state-和-setstate-的区别"><a href="#_2-3-react-组件中-this-state-和-setstate-的区别" class="header-anchor">#</a> 2.3 React 组件中 this.state 和 setState 的区别</h3> <p>this.state提供了读的能力<br>
this.state必须通过setState来修改</p> <h3 id="_2-4-react-组件的-state-和-props-的区别"><a href="#_2-4-react-组件的-state-和-props-的区别" class="header-anchor">#</a> 2.4 React 组件的 state 和 props 的区别</h3> <table><thead><tr><th></th> <th>state</th> <th>props</th></tr></thead> <tbody><tr><td>定义</td> <td>组件内部存储的状态</td> <td>从父组件传递给子组件的数据</td></tr> <tr><td>数据流向</td> <td>组件内部更新</td> <td>从父组件更新</td></tr> <tr><td>可变性</td> <td>通过setState更新</td> <td>只读，子组件不能修改</td></tr></tbody></table> <h3 id="_2-5-react-中的-setstate-批量更新的过程"><a href="#_2-5-react-中的-setstate-批量更新的过程" class="header-anchor">#</a> 2.5 React 中的 setState 批量更新的过程</h3> <ul><li>更新队列的创建</li> <li>事件处理函数结束后，生命周期后会触发 批量更新</li> <li>diff算法，更新dom</li></ul> <h3 id="_2-6-react-中-getdefaultprops-的作用"><a href="#_2-6-react-中-getdefaultprops-的作用" class="header-anchor">#</a> 2.6 React 中 getDefaultProps 的作用</h3> <h3 id="_2-7-react-中-props-只读的原因"><a href="#_2-7-react-中-props-只读的原因" class="header-anchor">#</a> 2.7 React 中 props 只读的原因</h3> <h3 id="_2-8-react-中组件的-props-改变时更新组件的方法"><a href="#_2-8-react-中组件的-props-改变时更新组件的方法" class="header-anchor">#</a> 2.8 React 中组件的 props 改变时更新组件的方法</h3> <h3 id="_2-9-react-中-setstate-的第二个参数作用"><a href="#_2-9-react-中-setstate-的第二个参数作用" class="header-anchor">#</a> 2.9 React 中 setState 的第二个参数作用</h3> <h3 id="_2-10-state-从-reducer-到组件的注入过程"><a href="#_2-10-state-从-reducer-到组件的注入过程" class="header-anchor">#</a> 2.10 state 从 reducer 到组件的注入过程</h3> <h3 id="_2-11-react-中检验-props-的方法及目的"><a href="#_2-11-react-中检验-props-的方法及目的" class="header-anchor">#</a> 2.11 React 中检验 props 的方法及目的</h3> <h3 id="_2-12-react-中的-setstate-和-replacestate-的区别"><a href="#_2-12-react-中的-setstate-和-replacestate-的区别" class="header-anchor">#</a> 2.12 React 中的 setState 和 replaceState 的区别</h3> <h2 id="三、生命周期"><a href="#三、生命周期" class="header-anchor">#</a> 三、生命周期</h2> <h3 id="_3-1-react-的生命周期阶段-挂载、更新、卸载、错误处理"><a href="#_3-1-react-的生命周期阶段-挂载、更新、卸载、错误处理" class="header-anchor">#</a> 3.1 React 的生命周期阶段（挂载、更新、卸载、错误处理）</h3> <p><img src="/assets/img/react-lifecycle.f88599b9.jpg" alt="image"> <strong>挂载阶段（Mounting）</strong></p> <ul><li>constructor()</li> <li>static getDerivedStateFromProps(props, state)</li> <li>render()</li> <li>componentDidMount()</li></ul> <p><strong>更新阶段（Updating）</strong></p> <ul><li>static getDerivedStateFromProps(props, state)</li> <li>shouldComponentUpdate(nextProps, nextState)</li> <li>render()</li> <li>componentDidUpdate(prevProps, prevState, snapshot)</li></ul> <p><strong>卸载阶段（Unmounting）</strong></p> <ul><li>componentWillUnmount()</li></ul> <p><strong>错误处理阶段（Error Handling）</strong></p> <ul><li>static getDerivedStateFromError(error)</li> <li>componentDidCatch(error, errorInfo)</li></ul> <h3 id="_3-2-react-性能优化的生命周期及原理"><a href="#_3-2-react-性能优化的生命周期及原理" class="header-anchor">#</a> 3.2 React 性能优化的生命周期及原理</h3> <p>shouldComponentUpdate</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>number <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>number <span class="token operator">&amp;&amp;</span> nextState<span class="token punctuation">.</span>square <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>square<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>React.memo PureComponent 原理是在shouldComponentUpdate 做了浅比较<br>
useMemo 缓存复杂计算<br>
useCallback 适合用于React.memo 优化的情况</p> <h3 id="_3-3-state-和-props-触发更新的生命周期区别"><a href="#_3-3-state-和-props-触发更新的生命周期区别" class="header-anchor">#</a> 3.3 state 和 props 触发更新的生命周期区别</h3> <p>state更新流程</p> <ul><li>更新操作放入更新队列（在 React 18 中会进行自动批处理）</li> <li>对于类组件，shouldComponentUpdate被触发</li> <li>render</li> <li>componentDidUpdate</li></ul> <p>props更新流程</p> <ul><li>static getDerivedStateFromProps</li> <li>shouldComponentUpdate</li> <li>render</li> <li>componentDidUpdate</li></ul> <h3 id="_3-4-react-中发起网络请求的生命周期及原因"><a href="#_3-4-react-中发起网络请求的生命周期及原因" class="header-anchor">#</a> 3.4 React 中发起网络请求的生命周期及原因</h3> <ul><li>componentDidMount</li> <li>componentDidUpdate 发起网络请求时，需要进行条件判断，以避免无限循环的请求。
如：根据关键词更新搜索结果时，可以在componentDidUpdate中判断关键词是否变化，如果变化则发起网络请求获取新的搜索结果</li></ul> <h3 id="_3-5-react-16-中新生命周期"><a href="#_3-5-react-16-中新生命周期" class="header-anchor">#</a> 3.5 React 16 中新生命周期</h3> <p><img src="/assets/img/react-lifecycle.f88599b9.jpg" alt="image"></p> <h3 id="_3-6-react-废弃的生命周期及原因"><a href="#_3-6-react-废弃的生命周期及原因" class="header-anchor">#</a> 3.6 React 废弃的生命周期及原因</h3> <p><strong>componentWillMount废弃的原因</strong><br>
React 一直在向异步渲染方向发展。在异步渲染环境下，componentWillMount的执行时机变得模糊。它原本是在组件挂载到 DOM 之前调用，主要用于初始化组件状态或执行一些只需要执行一次的操作。但随着异步渲染的引入，组件可能会被暂停、恢复或者重新排序渲染，这使得componentWillMount的执行顺序和时间难以预测。例如，在服务器端渲染（SSR）与客户端渲染（CSR）结合的场景中，componentWillMount可能会在服务器端和客户端分别执行，这可能导致意外的行为。</p> <p><strong>componentWillReceiveProps废弃的原因</strong><br>
容易引发复杂的状态更新逻辑<br>
React 引入了static getDerivedStateFromProps来替代其部分功能。static getDerivedStateFromProps是一个静态方法，它接收props和state作为参数，并且必须返回一个用于更新state的对象或者null。这种方式使得状态更新更加可控和可预测，避免了componentWillReceiveProps可能出现的副作用和复杂的更新逻辑</p> <p><strong>componentWillUpdate废弃的原因</strong><br>
异步渲染导致的不确定性</p> <h3 id="_3-7-react-16-x-中-props-改变后处理的生命周期"><a href="#_3-7-react-16-x-中-props-改变后处理的生命周期" class="header-anchor">#</a> 3.7 React 16.X 中 props 改变后处理的生命周期</h3> <ul><li>static getDerivedStateFromProps(props, state)</li> <li>shouldComponentUpdate(nextProps, nextState)</li> <li>render()</li> <li>componentDidUpdate(prevProps, prevState)</li></ul> <h2 id="四、组件通信"><a href="#四、组件通信" class="header-anchor">#</a> 四、组件通信</h2> <h3 id="_4-1-父子组件的通信方式"><a href="#_4-1-父子组件的通信方式" class="header-anchor">#</a> 4.1 父子组件的通信方式</h3> <h3 id="_4-2-跨级组件的通信方式"><a href="#_4-2-跨级组件的通信方式" class="header-anchor">#</a> 4.2 跨级组件的通信方式</h3> <h3 id="_4-3-非嵌套关系组件的通信方式"><a href="#_4-3-非嵌套关系组件的通信方式" class="header-anchor">#</a> 4.3 非嵌套关系组件的通信方式</h3> <h3 id="_4-4-组件通信的方式总结"><a href="#_4-4-组件通信的方式总结" class="header-anchor">#</a> 4.4 组件通信的方式总结</h3> <h3 id="_4-5-解决-props-层级过深的问题"><a href="#_4-5-解决-props-层级过深的问题" class="header-anchor">#</a> 4.5 解决 props 层级过深的问题</h3> <h2 id="五、路由"><a href="#五、路由" class="header-anchor">#</a> 五、路由</h2> <h3 id="_5-1-react-router-的实现原理"><a href="#_5-1-react-router-的实现原理" class="header-anchor">#</a> 5.1 React-Router 的实现原理</h3> <h3 id="_5-2-react-router-的路由模式"><a href="#_5-2-react-router-的路由模式" class="header-anchor">#</a> 5.2 React-Router 的路由模式</h3> <h3 id="_5-3-react-router4-路由变化时重新渲染同一个组件的方法"><a href="#_5-3-react-router4-路由变化时重新渲染同一个组件的方法" class="header-anchor">#</a> 5.3 React-Router4 路由变化时重新渲染同一个组件的方法</h3> <h3 id="_5-4-react-router4-的-switch-的作用"><a href="#_5-4-react-router4-的-switch-的作用" class="header-anchor">#</a> 5.4 React-Router4 的 Switch 的作用</h3> <h3 id="_5-5-配置-react-router-实现路由切换的方法"><a href="#_5-5-配置-react-router-实现路由切换的方法" class="header-anchor">#</a> 5.5 配置 React-Router 实现路由切换的方法</h3> <h3 id="_5-6-react-router-里的-link-标签和-a-标签的区别"><a href="#_5-6-react-router-里的-link-标签和-a-标签的区别" class="header-anchor">#</a> 5.6 react-router 里的 Link 标签和 a 标签的区别</h3> <h3 id="_5-7-react-router-获取-url-的参数和历史对象的方法"><a href="#_5-7-react-router-获取-url-的参数和历史对象的方法" class="header-anchor">#</a> 5.7 React-Router 获取 URL 的参数和历史对象的方法</h3> <h3 id="_5-8-react-router-设置重定向的方法"><a href="#_5-8-react-router-设置重定向的方法" class="header-anchor">#</a> 5.8 React-Router 设置重定向的方法</h3> <h2 id="六、redux"><a href="#六、redux" class="header-anchor">#</a> 六、Redux</h2> <h3 id="_6-1-对-redux-的理解及解决的问题"><a href="#_6-1-对-redux-的理解及解决的问题" class="header-anchor">#</a> 6.1 对 Redux 的理解及解决的问题</h3> <h3 id="_6-2-redux-原理及工作流程"><a href="#_6-2-redux-原理及工作流程" class="header-anchor">#</a> 6.2 Redux 原理及工作流程</h3> <h3 id="_6-3-redux-和-vuex-的区别及共同思想"><a href="#_6-3-redux-和-vuex-的区别及共同思想" class="header-anchor">#</a> 6.3 Redux 和 Vuex 的区别及共同思想</h3> <h3 id="_6-4-redux-中异步请求的处理方法"><a href="#_6-4-redux-中异步请求的处理方法" class="header-anchor">#</a> 6.4 Redux 中异步请求的处理方法</h3> <h3 id="_6-5-redux-实现属性传递的原理"><a href="#_6-5-redux-实现属性传递的原理" class="header-anchor">#</a> 6.5 Redux 实现属性传递的原理</h3> <h3 id="_6-6-redux-中间件的定义、参数及作用"><a href="#_6-6-redux-中间件的定义、参数及作用" class="header-anchor">#</a> 6.6 Redux 中间件的定义、参数及作用</h3> <h3 id="_6-7-redux-状态管理器和变量挂载到-window-的区别"><a href="#_6-7-redux-状态管理器和变量挂载到-window-的区别" class="header-anchor">#</a> 6.7 Redux 状态管理器和变量挂载到 window 的区别</h3> <h3 id="_6-8-mobox-和-redux-的区别"><a href="#_6-8-mobox-和-redux-的区别" class="header-anchor">#</a> 6.8 mobox 和 redux 的区别</h3> <h3 id="_6-9-redux-中的-connect-的作用"><a href="#_6-9-redux-中的-connect-的作用" class="header-anchor">#</a> 6.9 Redux 中的 connect 的作用</h3> <h3 id="_6-10-redux-请求中间件处理并发的方法"><a href="#_6-10-redux-请求中间件处理并发的方法" class="header-anchor">#</a> 6.10 Redux 请求中间件处理并发的方法</h3> <h3 id="_6-11-redux-中间件获取-store-和-action-的方法及处理方式"><a href="#_6-11-redux-中间件获取-store-和-action-的方法及处理方式" class="header-anchor">#</a> 6.11 Redux 中间件获取 store 和 action 的方法及处理方式</h3> <h2 id="七、hooks"><a href="#七、hooks" class="header-anchor">#</a> 七、Hooks</h2> <h3 id="_7-1-对-react-hook-的理解及实现原理"><a href="#_7-1-对-react-hook-的理解及实现原理" class="header-anchor">#</a> 7.1 对 React Hook 的理解及实现原理</h3> <h3 id="_7-2-为什么-usestate-要使用数组而不是对象"><a href="#_7-2-为什么-usestate-要使用数组而不是对象" class="header-anchor">#</a> 7.2 为什么 useState 要使用数组而不是对象</h3> <h3 id="_7-3-react-hooks-解决的问题"><a href="#_7-3-react-hooks-解决的问题" class="header-anchor">#</a> 7.3 React Hooks 解决的问题</h3> <h3 id="_7-4-useeffect-与-uselayouteffect-的区别"><a href="#_7-4-useeffect-与-uselayouteffect-的区别" class="header-anchor">#</a> 7.4 useEffect 与 useLayoutEffect 的区别</h3> <h3 id="_7-5-react-hook-的使用限制"><a href="#_7-5-react-hook-的使用限制" class="header-anchor">#</a> 7.5 React Hook 的使用限制</h3> <h3 id="_7-6-react-hooks-在开发中需要注意的问题及原因"><a href="#_7-6-react-hooks-在开发中需要注意的问题及原因" class="header-anchor">#</a> 7.6 React Hooks 在开发中需要注意的问题及原因</h3> <h3 id="_7-7-react-hooks-和生命周期的关系"><a href="#_7-7-react-hooks-和生命周期的关系" class="header-anchor">#</a> 7.7 React Hooks 和生命周期的关系</h3> <h2 id="八、虚拟-dom"><a href="#八、虚拟-dom" class="header-anchor">#</a> 八、虚拟 DOM</h2> <h3 id="_8-1-对虚拟-dom-的理解、作用及本身的定义"><a href="#_8-1-对虚拟-dom-的理解、作用及本身的定义" class="header-anchor">#</a> 8.1 对虚拟 DOM 的理解、作用及本身的定义</h3> <h3 id="_8-2-react-diff-算法的原理"><a href="#_8-2-react-diff-算法的原理" class="header-anchor">#</a> 8.2 React diff 算法的原理</h3> <h3 id="_8-3-react-key-的作用及解决的问题"><a href="#_8-3-react-key-的作用及解决的问题" class="header-anchor">#</a> 8.3 React key 的作用及解决的问题</h3> <h3 id="_8-4-虚拟-dom-与直接操作原生-dom-的效率比较及原因"><a href="#_8-4-虚拟-dom-与直接操作原生-dom-的效率比较及原因" class="header-anchor">#</a> 8.4 虚拟 DOM 与直接操作原生 DOM 的效率比较及原因</h3> <h3 id="_8-5-react-与-vue-的-diff-算法的不同"><a href="#_8-5-react-与-vue-的-diff-算法的不同" class="header-anchor">#</a> 8.5 React 与 Vue 的 diff 算法的不同</h3> <h2 id="九、其他"><a href="#九、其他" class="header-anchor">#</a> 九、其他</h2> <h3 id="_9-1-对-react-和-vue-的理解及异同"><a href="#_9-1-对-react-和-vue-的理解及异同" class="header-anchor">#</a> 9.1 对 React 和 Vue 的理解及异同</h3> <h3 id="_9-2-react-中的遍历方法"><a href="#_9-2-react-中的遍历方法" class="header-anchor">#</a> 9.2 React 中的遍历方法</h3> <h3 id="_9-3-对-react-ssr-的理解"><a href="#_9-3-对-react-ssr-的理解" class="header-anchor">#</a> 9.3 对 React SSR 的理解</h3> <h3 id="_9-4-react-要用-jsx-的原因"><a href="#_9-4-react-要用-jsx-的原因" class="header-anchor">#</a> 9.4 React 要用 JSX 的原因</h3> <h3 id="_9-5-react-最新版本解决的问题及增加的内容"><a href="#_9-5-react-最新版本解决的问题及增加的内容" class="header-anchor">#</a> 9.5 React 最新版本解决的问题及增加的内容</h3> <h3 id="_9-6-react-数据持久化的实践"><a href="#_9-6-react-数据持久化的实践" class="header-anchor">#</a> 9.6 React 数据持久化的实践</h3> <h3 id="_9-7-react-的设计思路及理念"><a href="#_9-7-react-的设计思路及理念" class="header-anchor">#</a> 9.7 React 的设计思路及理念</h3> <h3 id="_9-8-react-中-props-children-和-react-children-的区别"><a href="#_9-8-react-中-props-children-和-react-children-的区别" class="header-anchor">#</a> 9.8 React 中 props.children 和 React.Children 的区别</h3> <h3 id="_9-9-react-的状态提升及使用场景"><a href="#_9-9-react-的状态提升及使用场景" class="header-anchor">#</a> 9.9 React 的状态提升及使用场景</h3> <h3 id="_9-10-同时引用-react-js、react-dom-js-和-babel-js-的作用"><a href="#_9-10-同时引用-react-js、react-dom-js-和-babel-js-的作用" class="header-anchor">#</a> 9.10 同时引用 react.js、react-dom.js 和 babel.js 的作用</h3> <h3 id="_9-11-react-children-map-和-js-的-map-的区别"><a href="#_9-11-react-children-map-和-js-的-map-的区别" class="header-anchor">#</a> 9.11 React.Children.map 和 js 的 map 的区别</h3> <h3 id="_9-12-react-组件命名的推荐方式"><a href="#_9-12-react-组件命名的推荐方式" class="header-anchor">#</a> 9.12 React 组件命名的推荐方式</h3> <h3 id="_9-13-react-实现全局-dialog-的方法"><a href="#_9-13-react-实现全局-dialog-的方法" class="header-anchor">#</a> 9.13 React 实现全局 dialog 的方法</h3> <h3 id="_9-14-react-页面重新加载时保留数据的方法"><a href="#_9-14-react-页面重新加载时保留数据的方法" class="header-anchor">#</a> 9.14 React 页面重新加载时保留数据的方法</h3> <h3 id="_9-15-react-中使用-async-await-的方法"><a href="#_9-15-react-中使用-async-await-的方法" class="header-anchor">#</a> 9.15 React 中使用 async/await 的方法</h3> <h3 id="_9-16-使用-typescript-写-react-应用的方法"><a href="#_9-16-使用-typescript-写-react-应用的方法" class="header-anchor">#</a> 9.16 使用 TypeScript 写 React 应用的方法</h3> <h3 id="_9-17-react-中-constructor-和-getinitialstate-的区别"><a href="#_9-17-react-中-constructor-和-getinitialstate-的区别" class="header-anchor">#</a> 9.17 React 中 constructor 和 getInitialState 的区别</h3> <h3 id="_9-18-react-的严格模式的使用方法及用处"><a href="#_9-18-react-的严格模式的使用方法及用处" class="header-anchor">#</a> 9.18 React 的严格模式的使用方法及用处</h3> <h3 id="_9-19-为什么使用-jsx-的组件中没看到使用-react-却需要引入-react"><a href="#_9-19-为什么使用-jsx-的组件中没看到使用-react-却需要引入-react" class="header-anchor">#</a> 9.19 为什么使用 jsx 的组件中没看到使用 react 却需要引入 react</h3> <h3 id="_9-20-hoc-相比-mixins-的优点"><a href="#_9-20-hoc-相比-mixins-的优点" class="header-anchor">#</a> 9.20 HOC 相比 mixins 的优点</h3> <h3 id="_9-21-react-中的高阶组件运用的设计模式"><a href="#_9-21-react-中的高阶组件运用的设计模式" class="header-anchor">#</a> 9.21 React 中的高阶组件运用的设计模式</h3></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#一、组件基础" title="一、组件基础">一、组件基础</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-1-react-事件机制" title="1.1 React 事件机制">1.1 React 事件机制</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-2-react-高阶组件、render-props、hooks-的区别及迭代原因" title="1.2 React 高阶组件、Render props、hooks 的区别及迭代原因">1.2 React 高阶组件、Render props、hooks 的区别及迭代原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-3-对-react-fiber-的理解及解决的问题" title="1.3 对 React-Fiber 的理解及解决的问题">1.3 对 React-Fiber 的理解及解决的问题</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-4-react-高阶组件的定义、与普通组件的区别及适用场景" title="1.4 React 高阶组件的定义、与普通组件的区别及适用场景">1.4 React 高阶组件的定义、与普通组件的区别及适用场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-5-触发-react-重新渲染的方法及重新渲染时-render-的作用" title="1.5 触发 React 重新渲染的方法及重新渲染时 render 的作用">1.5 触发 React 重新渲染的方法及重新渲染时 render 的作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-6-有状态组件和无状态组件的理解与使用场景" title="1.6 有状态组件和无状态组件的理解与使用场景">1.6 有状态组件和无状态组件的理解与使用场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-7-react-中的受控组件和非控组件" title="1.7 React 中的受控组件和非控组件">1.7 React 中的受控组件和非控组件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-8-类组件与函数组件的异同" title="1.8 类组件与函数组件的异同">1.8 类组件与函数组件的异同</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-9-react-的事件与普通-html-事件的不同" title="1.9 React 的事件与普通 HTML 事件的不同">1.9 React 的事件与普通 HTML 事件的不同</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-10-react-createclass-和-extends-component-的区别" title="1.10 React.createClass 和 extends Component 的区别">1.10 React.createClass 和 extends Component 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-11-react-判断重新渲染组件的方式" title="1.11 React 判断重新渲染组件的方式">1.11 React 判断重新渲染组件的方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-12-对-react-中-fragment-的理解及使用场景" title="1.12 对 React 中 Fragment 的理解及使用场景">1.12 对 React 中 Fragment 的理解及使用场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-13-react-获取组件对应的-dom-元素的方法" title="1.13 React 获取组件对应的 DOM 元素的方法">1.13 React 获取组件对应的 DOM 元素的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-14-对-react-的插槽-portals-的理解、使用方法及场景" title="1.14 对 React 的插槽（Portals）的理解、使用方法及场景">1.14 对 React 的插槽（Portals）的理解、使用方法及场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-15-在-react-中避免不必要-render-的方法" title="1.15 在 React 中避免不必要 render 的方法">1.15 在 React 中避免不必要 render 的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-16-对-react-intl-的理解及工作原理" title="1.16 对 React-Intl 的理解及工作原理">1.16 对 React-Intl 的理解及工作原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-17-对-react-context-的理解" title="1.17 对 React context 的理解">1.17 对 React context 的理解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-18-react-中绑定-this-的其他方式" title="1.18 React 中绑定 this 的其他方式">1.18 React 中绑定 this 的其他方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-19-react-组件中事件代理的方法及原理" title="1.19 React 组件中事件代理的方法及原理">1.19 React 组件中事件代理的方法及原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-20-react-component-和-react-purecomponent-的区别" title="1.20 React.Component 和 React.PureComponent 的区别">1.20 React.Component 和 React.PureComponent 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-21-component-element-instance-之间的区别与联系" title="1.21 Component, Element, Instance 之间的区别与联系">1.21 Component, Element, Instance 之间的区别与联系</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-22-react-声明组件的方法及区别" title="1.22 React 声明组件的方法及区别">1.22 React 声明组件的方法及区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-23-react-中在-render-访问-refs-的情况及原因" title="1.23 React 中在 render 访问 refs 的情况及原因">1.23 React 中在 render 访问 refs 的情况及原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-24-为什么-react-不推荐优先考虑使用-context" title="1.24 为什么 React 不推荐优先考虑使用 Context">1.24 为什么 React 不推荐优先考虑使用 Context</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-25-react-中-refs-的作用及应用场景" title="1.25 React 中 refs 的作用及应用场景">1.25 React 中 refs 的作用及应用场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-26-react-组件的构造函数的作用及必要性" title="1.26 React 组件的构造函数的作用及必要性">1.26 React 组件的构造函数的作用及必要性</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-27-对-componentwillreceiveprops-的理解" title="1.27 对 componentWillReceiveProps 的理解">1.27 对 componentWillReceiveProps 的理解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-28-react-forwardref-的定义及作用" title="1.28 React.forwardRef 的定义及作用">1.28 React.forwardRef 的定义及作用</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#二、数据管理" title="二、数据管理">二、数据管理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-1-react-setstate-调用的原理" title="2.1 React setState 调用的原理">2.1 React setState 调用的原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-2-react-setstate-调用之后的情况-同步或异步" title="2.2 React setState 调用之后的情况（同步或异步）">2.2 React setState 调用之后的情况（同步或异步）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-3-react-组件中-this-state-和-setstate-的区别" title="2.3 React 组件中 this.state 和 setState 的区别">2.3 React 组件中 this.state 和 setState 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-4-react-组件的-state-和-props-的区别" title="2.4 React 组件的 state 和 props 的区别">2.4 React 组件的 state 和 props 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-5-react-中的-setstate-批量更新的过程" title="2.5 React 中的 setState 批量更新的过程">2.5 React 中的 setState 批量更新的过程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-6-react-中-getdefaultprops-的作用" title="2.6 React 中 getDefaultProps 的作用">2.6 React 中 getDefaultProps 的作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-7-react-中-props-只读的原因" title="2.7 React 中 props 只读的原因">2.7 React 中 props 只读的原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-8-react-中组件的-props-改变时更新组件的方法" title="2.8 React 中组件的 props 改变时更新组件的方法">2.8 React 中组件的 props 改变时更新组件的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-9-react-中-setstate-的第二个参数作用" title="2.9 React 中 setState 的第二个参数作用">2.9 React 中 setState 的第二个参数作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-10-state-从-reducer-到组件的注入过程" title="2.10 state 从 reducer 到组件的注入过程">2.10 state 从 reducer 到组件的注入过程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-11-react-中检验-props-的方法及目的" title="2.11 React 中检验 props 的方法及目的">2.11 React 中检验 props 的方法及目的</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-12-react-中的-setstate-和-replacestate-的区别" title="2.12 React 中的 setState 和 replaceState 的区别">2.12 React 中的 setState 和 replaceState 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#三、生命周期" title="三、生命周期">三、生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-1-react-的生命周期阶段-挂载、更新、卸载、错误处理" title="3.1 React 的生命周期阶段（挂载、更新、卸载、错误处理）">3.1 React 的生命周期阶段（挂载、更新、卸载、错误处理）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-2-react-性能优化的生命周期及原理" title="3.2 React 性能优化的生命周期及原理">3.2 React 性能优化的生命周期及原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-3-state-和-props-触发更新的生命周期区别" title="3.3 state 和 props 触发更新的生命周期区别">3.3 state 和 props 触发更新的生命周期区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-4-react-中发起网络请求的生命周期及原因" title="3.4 React 中发起网络请求的生命周期及原因">3.4 React 中发起网络请求的生命周期及原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-5-react-16-中新生命周期" title="3.5 React 16 中新生命周期">3.5 React 16 中新生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-6-react-废弃的生命周期及原因" title="3.6 React 废弃的生命周期及原因">3.6 React 废弃的生命周期及原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-7-react-16-x-中-props-改变后处理的生命周期" title="3.7 React 16.X 中 props 改变后处理的生命周期">3.7 React 16.X 中 props 改变后处理的生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#四、组件通信" title="四、组件通信">四、组件通信</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-1-父子组件的通信方式" title="4.1 父子组件的通信方式">4.1 父子组件的通信方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-2-跨级组件的通信方式" title="4.2 跨级组件的通信方式">4.2 跨级组件的通信方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-3-非嵌套关系组件的通信方式" title="4.3 非嵌套关系组件的通信方式">4.3 非嵌套关系组件的通信方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-4-组件通信的方式总结" title="4.4 组件通信的方式总结">4.4 组件通信的方式总结</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-5-解决-props-层级过深的问题" title="4.5 解决 props 层级过深的问题">4.5 解决 props 层级过深的问题</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#五、路由" title="五、路由">五、路由</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-1-react-router-的实现原理" title="5.1 React-Router 的实现原理">5.1 React-Router 的实现原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-2-react-router-的路由模式" title="5.2 React-Router 的路由模式">5.2 React-Router 的路由模式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-3-react-router4-路由变化时重新渲染同一个组件的方法" title="5.3 React-Router4 路由变化时重新渲染同一个组件的方法">5.3 React-Router4 路由变化时重新渲染同一个组件的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-4-react-router4-的-switch-的作用" title="5.4 React-Router4 的 Switch 的作用">5.4 React-Router4 的 Switch 的作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-5-配置-react-router-实现路由切换的方法" title="5.5 配置 React-Router 实现路由切换的方法">5.5 配置 React-Router 实现路由切换的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-6-react-router-里的-link-标签和-a-标签的区别" title="5.6 react-router 里的 Link 标签和 a 标签的区别">5.6 react-router 里的 Link 标签和 a 标签的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-7-react-router-获取-url-的参数和历史对象的方法" title="5.7 React-Router 获取 URL 的参数和历史对象的方法">5.7 React-Router 获取 URL 的参数和历史对象的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-8-react-router-设置重定向的方法" title="5.8 React-Router 设置重定向的方法">5.8 React-Router 设置重定向的方法</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#六、redux" title="六、Redux">六、Redux</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-1-对-redux-的理解及解决的问题" title="6.1 对 Redux 的理解及解决的问题">6.1 对 Redux 的理解及解决的问题</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-2-redux-原理及工作流程" title="6.2 Redux 原理及工作流程">6.2 Redux 原理及工作流程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-3-redux-和-vuex-的区别及共同思想" title="6.3 Redux 和 Vuex 的区别及共同思想">6.3 Redux 和 Vuex 的区别及共同思想</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-4-redux-中异步请求的处理方法" title="6.4 Redux 中异步请求的处理方法">6.4 Redux 中异步请求的处理方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-5-redux-实现属性传递的原理" title="6.5 Redux 实现属性传递的原理">6.5 Redux 实现属性传递的原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-6-redux-中间件的定义、参数及作用" title="6.6 Redux 中间件的定义、参数及作用">6.6 Redux 中间件的定义、参数及作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-7-redux-状态管理器和变量挂载到-window-的区别" title="6.7 Redux 状态管理器和变量挂载到 window 的区别">6.7 Redux 状态管理器和变量挂载到 window 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-8-mobox-和-redux-的区别" title="6.8 mobox 和 redux 的区别">6.8 mobox 和 redux 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-9-redux-中的-connect-的作用" title="6.9 Redux 中的 connect 的作用">6.9 Redux 中的 connect 的作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-10-redux-请求中间件处理并发的方法" title="6.10 Redux 请求中间件处理并发的方法">6.10 Redux 请求中间件处理并发的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-11-redux-中间件获取-store-和-action-的方法及处理方式" title="6.11 Redux 中间件获取 store 和 action 的方法及处理方式">6.11 Redux 中间件获取 store 和 action 的方法及处理方式</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#七、hooks" title="七、Hooks">七、Hooks</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-1-对-react-hook-的理解及实现原理" title="7.1 对 React Hook 的理解及实现原理">7.1 对 React Hook 的理解及实现原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-2-为什么-usestate-要使用数组而不是对象" title="7.2 为什么 useState 要使用数组而不是对象">7.2 为什么 useState 要使用数组而不是对象</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-3-react-hooks-解决的问题" title="7.3 React Hooks 解决的问题">7.3 React Hooks 解决的问题</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-4-useeffect-与-uselayouteffect-的区别" title="7.4 useEffect 与 useLayoutEffect 的区别">7.4 useEffect 与 useLayoutEffect 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-5-react-hook-的使用限制" title="7.5 React Hook 的使用限制">7.5 React Hook 的使用限制</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-6-react-hooks-在开发中需要注意的问题及原因" title="7.6 React Hooks 在开发中需要注意的问题及原因">7.6 React Hooks 在开发中需要注意的问题及原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_7-7-react-hooks-和生命周期的关系" title="7.7 React Hooks 和生命周期的关系">7.7 React Hooks 和生命周期的关系</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#八、虚拟-dom" title="八、虚拟 DOM">八、虚拟 DOM</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_8-1-对虚拟-dom-的理解、作用及本身的定义" title="8.1 对虚拟 DOM 的理解、作用及本身的定义">8.1 对虚拟 DOM 的理解、作用及本身的定义</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_8-2-react-diff-算法的原理" title="8.2 React diff 算法的原理">8.2 React diff 算法的原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_8-3-react-key-的作用及解决的问题" title="8.3 React key 的作用及解决的问题">8.3 React key 的作用及解决的问题</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_8-4-虚拟-dom-与直接操作原生-dom-的效率比较及原因" title="8.4 虚拟 DOM 与直接操作原生 DOM 的效率比较及原因">8.4 虚拟 DOM 与直接操作原生 DOM 的效率比较及原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_8-5-react-与-vue-的-diff-算法的不同" title="8.5 React 与 Vue 的 diff 算法的不同">8.5 React 与 Vue 的 diff 算法的不同</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#九、其他" title="九、其他">九、其他</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-1-对-react-和-vue-的理解及异同" title="9.1 对 React 和 Vue 的理解及异同">9.1 对 React 和 Vue 的理解及异同</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-2-react-中的遍历方法" title="9.2 React 中的遍历方法">9.2 React 中的遍历方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-3-对-react-ssr-的理解" title="9.3 对 React SSR 的理解">9.3 对 React SSR 的理解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-4-react-要用-jsx-的原因" title="9.4 React 要用 JSX 的原因">9.4 React 要用 JSX 的原因</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-5-react-最新版本解决的问题及增加的内容" title="9.5 React 最新版本解决的问题及增加的内容">9.5 React 最新版本解决的问题及增加的内容</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-6-react-数据持久化的实践" title="9.6 React 数据持久化的实践">9.6 React 数据持久化的实践</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-7-react-的设计思路及理念" title="9.7 React 的设计思路及理念">9.7 React 的设计思路及理念</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-8-react-中-props-children-和-react-children-的区别" title="9.8 React 中 props.children 和 React.Children 的区别">9.8 React 中 props.children 和 React.Children 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-9-react-的状态提升及使用场景" title="9.9 React 的状态提升及使用场景">9.9 React 的状态提升及使用场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-10-同时引用-react-js、react-dom-js-和-babel-js-的作用" title="9.10 同时引用 react.js、react-dom.js 和 babel.js 的作用">9.10 同时引用 react.js、react-dom.js 和 babel.js 的作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-11-react-children-map-和-js-的-map-的区别" title="9.11 React.Children.map 和 js 的 map 的区别">9.11 React.Children.map 和 js 的 map 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-12-react-组件命名的推荐方式" title="9.12 React 组件命名的推荐方式">9.12 React 组件命名的推荐方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-13-react-实现全局-dialog-的方法" title="9.13 React 实现全局 dialog 的方法">9.13 React 实现全局 dialog 的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-14-react-页面重新加载时保留数据的方法" title="9.14 React 页面重新加载时保留数据的方法">9.14 React 页面重新加载时保留数据的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-15-react-中使用-async-await-的方法" title="9.15 React 中使用 async/await 的方法">9.15 React 中使用 async/await 的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-16-使用-typescript-写-react-应用的方法" title="9.16 使用 TypeScript 写 React 应用的方法">9.16 使用 TypeScript 写 React 应用的方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-17-react-中-constructor-和-getinitialstate-的区别" title="9.17 React 中 constructor 和 getInitialState 的区别">9.17 React 中 constructor 和 getInitialState 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-18-react-的严格模式的使用方法及用处" title="9.18 React 的严格模式的使用方法及用处">9.18 React 的严格模式的使用方法及用处</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-19-为什么使用-jsx-的组件中没看到使用-react-却需要引入-react" title="9.19 为什么使用 jsx 的组件中没看到使用 react 却需要引入 react">9.19 为什么使用 jsx 的组件中没看到使用 react 却需要引入 react</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-20-hoc-相比-mixins-的优点" title="9.20 HOC 相比 mixins 的优点">9.20 HOC 相比 mixins 的优点</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_9-21-react-中的高阶组件运用的设计模式" title="9.21 React 中的高阶组件运用的设计模式">9.21 React 中的高阶组件运用的设计模式</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/fullyouth" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.216c6cc3.js" defer></script><script src="/assets/js/4.ca613f77.js" defer></script><script src="/assets/js/1.d3222c82.js" defer></script><script src="/assets/js/20.efced8ed.js" defer></script>
  </body>
</html>
