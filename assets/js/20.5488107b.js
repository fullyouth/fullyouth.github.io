(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{327:function(t,a,e){t.exports=e.p+"assets/img/react-lifecycle.f88599b9.jpg"},356:function(t,a,e){t.exports=e.p+"assets/img/React-event.3f9c15e4.png"},405:function(t,a,e){"use strict";e.r(a);var r=e(5),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-知识大纲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-知识大纲"}},[t._v("#")]),t._v(" React 知识大纲")]),t._v(" "),a("h2",{attrs:{id:"一、组件基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、组件基础"}},[t._v("#")]),t._v(" 一、组件基础")]),t._v(" "),a("h3",{attrs:{id:"_1-1-react-事件机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-react-事件机制"}},[t._v("#")]),t._v(" 1.1 React 事件机制")]),t._v(" "),a("p",[a("img",{attrs:{src:e(356),alt:"image"}})]),t._v(" "),a("h3",{attrs:{id:"_1-2-react-高阶组件、render-props、hooks-的区别及迭代原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-react-高阶组件、render-props、hooks-的区别及迭代原因"}},[t._v("#")]),t._v(" 1.2 React 高阶组件、Render props、hooks 的区别及迭代原因")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/z-memo/interview/issues/219",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/z-memo/interview/issues/219"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_1-3-对-react-fiber-的理解及解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-对-react-fiber-的理解及解决的问题"}},[t._v("#")]),t._v(" 1.3 对 React-Fiber 的理解及解决的问题")]),t._v(" "),a("h3",{attrs:{id:"_1-4-react-高阶组件的定义、与普通组件的区别及适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-react-高阶组件的定义、与普通组件的区别及适用场景"}},[t._v("#")]),t._v(" 1.4 React 高阶组件的定义、与普通组件的区别及适用场景")]),t._v(" "),a("h3",{attrs:{id:"_1-5-触发-react-重新渲染的方法及重新渲染时-render-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-触发-react-重新渲染的方法及重新渲染时-render-的作用"}},[t._v("#")]),t._v(" 1.5 触发 React 重新渲染的方法及重新渲染时 render 的作用")]),t._v(" "),a("h3",{attrs:{id:"_1-6-有状态组件和无状态组件的理解与使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-有状态组件和无状态组件的理解与使用场景"}},[t._v("#")]),t._v(" 1.6 有状态组件和无状态组件的理解与使用场景")]),t._v(" "),a("p",[a("strong",[t._v("有状态组件")]),a("br"),t._v("\n定义：在组件内部能够维护和管理状态（state）的组件")]),t._v(" "),a("ul",[a("li",[t._v("需要处理用户交互")]),t._v(" "),a("li",[t._v("复杂的业务逻辑和状态管理")])]),t._v(" "),a("p",[a("strong",[t._v("无状态组件")]),a("br"),t._v("\n定义：组件内部没有自己的状态（它只接收外部传入的属性（props），并根据这些属性来渲染输出，无状态组件是一个纯函数，对于相同的输入（即相同的属性），它总是返回相同的输出）")]),t._v(" "),a("ul",[a("li",[t._v("展示静态数据或简单的动态数据（基于传入属性）")]),t._v(" "),a("li",[t._v("方便用于组合和复用")]),t._v(" "),a("li",[t._v("有利于react性能优化（无状态组件是可预测的。如果组件不变，props不变，就不需要重新render）")])]),t._v(" "),a("h3",{attrs:{id:"_1-7-react-中的受控组件和非控组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-react-中的受控组件和非控组件"}},[t._v("#")]),t._v(" 1.7 React 中的受控组件和非控组件")]),t._v(" "),a("h3",{attrs:{id:"_1-8-类组件与函数组件的异同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-类组件与函数组件的异同"}},[t._v("#")]),t._v(" 1.8 类组件与函数组件的异同")]),t._v(" "),a("h3",{attrs:{id:"_1-9-react-的事件与普通-html-事件的不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-react-的事件与普通-html-事件的不同"}},[t._v("#")]),t._v(" 1.9 React 的事件与普通 HTML 事件的不同")]),t._v(" "),a("h3",{attrs:{id:"_1-10-react-createclass-和-extends-component-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-10-react-createclass-和-extends-component-的区别"}},[t._v("#")]),t._v(" 1.10 React.createClass 和 extends Component 的区别")]),t._v(" "),a("h3",{attrs:{id:"_1-11-react-判断重新渲染组件的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-11-react-判断重新渲染组件的方式"}},[t._v("#")]),t._v(" 1.11 React 判断重新渲染组件的方式")]),t._v(" "),a("h3",{attrs:{id:"_1-12-对-react-中-fragment-的理解及使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-12-对-react-中-fragment-的理解及使用场景"}},[t._v("#")]),t._v(" 1.12 对 React 中 Fragment 的理解及使用场景")]),t._v(" "),a("h3",{attrs:{id:"_1-13-react-获取组件对应的-dom-元素的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-13-react-获取组件对应的-dom-元素的方法"}},[t._v("#")]),t._v(" 1.13 React 获取组件对应的 DOM 元素的方法")]),t._v(" "),a("p",[t._v("ref")]),t._v(" "),a("h3",{attrs:{id:"_1-14-对-react-的插槽-portals-的理解、使用方法及场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-14-对-react-的插槽-portals-的理解、使用方法及场景"}},[t._v("#")]),t._v(" 1.14 对 React 的插槽（Portals）的理解、使用方法及场景")]),t._v(" "),a("p",[t._v("可以让一个组件的内容 “跳出” 它原本所在的组件层级，出现在页面的其他位置")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("ReactDOM"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createPortal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Comp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("主要用于弹窗浮层中")]),t._v(" "),a("h3",{attrs:{id:"_1-15-在-react-中避免不必要-render-的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-15-在-react-中避免不必要-render-的方法"}},[t._v("#")]),t._v(" 1.15 在 React 中避免不必要 render 的方法")]),t._v(" "),a("h3",{attrs:{id:"_1-16-对-react-intl-的理解及工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-16-对-react-intl-的理解及工作原理"}},[t._v("#")]),t._v(" 1.16 对 React-Intl 的理解及工作原理")]),t._v(" "),a("h3",{attrs:{id:"_1-17-对-react-context-的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-17-对-react-context-的理解"}},[t._v("#")]),t._v(" 1.17 对 React context 的理解")]),t._v(" "),a("h3",{attrs:{id:"_1-18-react-中绑定-this-的其他方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-18-react-中绑定-this-的其他方式"}},[t._v("#")]),t._v(" 1.18 React 中绑定 this 的其他方式")]),t._v(" "),a("h3",{attrs:{id:"_1-19-react-组件中事件代理的方法及原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-19-react-组件中事件代理的方法及原理"}},[t._v("#")]),t._v(" 1.19 React 组件中事件代理的方法及原理")]),t._v(" "),a("h3",{attrs:{id:"_1-20-react-component-和-react-purecomponent-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-20-react-component-和-react-purecomponent-的区别"}},[t._v("#")]),t._v(" 1.20 React.Component 和 React.PureComponent 的区别")]),t._v(" "),a("h3",{attrs:{id:"_1-21-component-element-instance-之间的区别与联系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-21-component-element-instance-之间的区别与联系"}},[t._v("#")]),t._v(" 1.21 Component, Element, Instance 之间的区别与联系")]),t._v(" "),a("h3",{attrs:{id:"_1-22-react-声明组件的方法及区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-22-react-声明组件的方法及区别"}},[t._v("#")]),t._v(" 1.22 React 声明组件的方法及区别")]),t._v(" "),a("h3",{attrs:{id:"_1-23-react-中在-render-访问-refs-的情况及原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-23-react-中在-render-访问-refs-的情况及原因"}},[t._v("#")]),t._v(" 1.23 React 中在 render 访问 refs 的情况及原因")]),t._v(" "),a("h3",{attrs:{id:"_1-24-为什么-react-不推荐优先考虑使用-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-24-为什么-react-不推荐优先考虑使用-context"}},[t._v("#")]),t._v(" 1.24 为什么 React 不推荐优先考虑使用 Context")]),t._v(" "),a("h3",{attrs:{id:"_1-25-react-中-refs-的作用及应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-25-react-中-refs-的作用及应用场景"}},[t._v("#")]),t._v(" 1.25 React 中 refs 的作用及应用场景")]),t._v(" "),a("h3",{attrs:{id:"_1-26-react-组件的构造函数的作用及必要性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-26-react-组件的构造函数的作用及必要性"}},[t._v("#")]),t._v(" 1.26 React 组件的构造函数的作用及必要性")]),t._v(" "),a("ul",[a("li",[t._v("继承父类React.Component,使用Super关键字")]),t._v(" "),a("li",[t._v("初始化state,mounted之前的默认值")]),t._v(" "),a("li",[t._v("绑定函数"),a("code",[t._v("fn.bind(this)")])])]),t._v(" "),a("h3",{attrs:{id:"_1-27-对-componentwillreceiveprops-的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-27-对-componentwillreceiveprops-的理解"}},[t._v("#")]),t._v(" 1.27 对 componentWillReceiveProps 的理解")]),t._v(" "),a("p",[a("img",{attrs:{src:e(327),alt:"image"}})]),t._v(" "),a("p",[a("code",[t._v("componentWillMount")]),t._v("和"),a("code",[t._v("componentWillReceiveProps")]),t._v(" 已经被废弃"),a("br"),t._v("\n原因：异步渲染过程中可能会因为多次调用而导致状态更新不一致")]),t._v(" "),a("p",[t._v("替代方案："),a("code",[t._v("getDerivedStateFromProps")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDerivedStateFromProps")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" state")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("initialValue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以一步获取接口数据")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是不能获取组件实例this")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("count")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("initialValue "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"_1-28-react-forwardref-的定义及作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-28-react-forwardref-的定义及作用"}},[t._v("#")]),t._v(" 1.28 React.forwardRef 的定义及作用")]),t._v(" "),a("p",[t._v("forwardRef 允许组件使用 ref 将 DOM 节点暴露给父组件")]),t._v(" "),a("p",[t._v("用法：")]),t._v(" "),a("ul",[a("li",[t._v("将 DOM 节点暴露给父组件")]),t._v(" "),a("li",[t._v("在多个组件中转发 ref")]),t._v(" "),a("li",[t._v("暴露命令式句柄（结合useImperativeHandle）")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" SomeComponent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forwardRef")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("render"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" MyInput "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forwardRef")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MyInput")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ref")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("label"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("label"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("input ref"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("label"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("不应该滥用ref，这些场景可以使用：滚动到节点、将焦点放在节点上、触发动画，以及选择文本等等"),a("br"),t._v("\n如果可以将某些东西使用 props 表达，那就不应该使用 ref")]),t._v(" "),a("h2",{attrs:{id:"二、数据管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、数据管理"}},[t._v("#")]),t._v(" 二、数据管理")]),t._v(" "),a("h3",{attrs:{id:"_2-1-react-setstate-调用的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-react-setstate-调用的原理"}},[t._v("#")]),t._v(" 2.1 React setState 调用的原理")]),t._v(" "),a("p",[t._v("一句话介绍：调用setState，更新state，从而更新UI"),a("br"),t._v("\n原理："),a("br"),t._v(" "),a("strong",[t._v("异步更新")]),t._v("： React为了提高性能，不可能更改state之后，同步更新UI，所以这是一个异步的过程\n"),a("strong",[t._v("批处理")]),t._v("： 每次调用setState，会提交一个更新state队列，在合适的时机对这些队列进行批处理")]),t._v(" "),a("h3",{attrs:{id:"_2-2-react-setstate-调用之后的情况-同步或异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-react-setstate-调用之后的情况-同步或异步"}},[t._v("#")]),t._v(" 2.2 React setState 调用之后的情况（同步或异步）")]),t._v(" "),a("p",[t._v("分情况"),a("br"),t._v("\nReact 18 之前"),a("br"),t._v("\n合成事件系统之内的是异步更新，之外是同步更新\n如setTimeout，直接绑定在dom上的事件，this.setState回调函数，都是同步更新")]),t._v(" "),a("p",[t._v("React 18 之后"),a("br"),t._v("\n实现了自动批处理，setTimeout，直接绑定在dom上的事件，")]),t._v(" "),a("h3",{attrs:{id:"_2-3-react-组件中-this-state-和-setstate-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-react-组件中-this-state-和-setstate-的区别"}},[t._v("#")]),t._v(" 2.3 React 组件中 this.state 和 setState 的区别")]),t._v(" "),a("p",[t._v("this.state提供了读的能力"),a("br"),t._v("\nthis.state必须通过setState来修改")]),t._v(" "),a("h3",{attrs:{id:"_2-4-react-组件的-state-和-props-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-react-组件的-state-和-props-的区别"}},[t._v("#")]),t._v(" 2.4 React 组件的 state 和 props 的区别")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th",[t._v("state")]),t._v(" "),a("th",[t._v("props")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("定义")]),t._v(" "),a("td",[t._v("组件内部存储的状态")]),t._v(" "),a("td",[t._v("从父组件传递给子组件的数据")])]),t._v(" "),a("tr",[a("td",[t._v("数据流向")]),t._v(" "),a("td",[t._v("组件内部更新")]),t._v(" "),a("td",[t._v("从父组件更新")])]),t._v(" "),a("tr",[a("td",[t._v("可变性")]),t._v(" "),a("td",[t._v("通过setState更新")]),t._v(" "),a("td",[t._v("只读，子组件不能修改")])])])]),t._v(" "),a("h3",{attrs:{id:"_2-5-react-中的-setstate-批量更新的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-react-中的-setstate-批量更新的过程"}},[t._v("#")]),t._v(" 2.5 React 中的 setState 批量更新的过程")]),t._v(" "),a("ul",[a("li",[t._v("更新队列的创建")]),t._v(" "),a("li",[t._v("事件处理函数结束后，生命周期后会触发 批量更新")]),t._v(" "),a("li",[t._v("diff算法，更新dom")])]),t._v(" "),a("h3",{attrs:{id:"_2-6-react-中-getdefaultprops-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-react-中-getdefaultprops-的作用"}},[t._v("#")]),t._v(" 2.6 React 中 getDefaultProps 的作用")]),t._v(" "),a("h3",{attrs:{id:"_2-7-react-中-props-只读的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-react-中-props-只读的原因"}},[t._v("#")]),t._v(" 2.7 React 中 props 只读的原因")]),t._v(" "),a("h3",{attrs:{id:"_2-8-react-中组件的-props-改变时更新组件的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-react-中组件的-props-改变时更新组件的方法"}},[t._v("#")]),t._v(" 2.8 React 中组件的 props 改变时更新组件的方法")]),t._v(" "),a("h3",{attrs:{id:"_2-9-react-中-setstate-的第二个参数作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-9-react-中-setstate-的第二个参数作用"}},[t._v("#")]),t._v(" 2.9 React 中 setState 的第二个参数作用")]),t._v(" "),a("h3",{attrs:{id:"_2-10-state-从-reducer-到组件的注入过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-10-state-从-reducer-到组件的注入过程"}},[t._v("#")]),t._v(" 2.10 state 从 reducer 到组件的注入过程")]),t._v(" "),a("h3",{attrs:{id:"_2-11-react-中检验-props-的方法及目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-11-react-中检验-props-的方法及目的"}},[t._v("#")]),t._v(" 2.11 React 中检验 props 的方法及目的")]),t._v(" "),a("h3",{attrs:{id:"_2-12-react-中的-setstate-和-replacestate-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-12-react-中的-setstate-和-replacestate-的区别"}},[t._v("#")]),t._v(" 2.12 React 中的 setState 和 replaceState 的区别")]),t._v(" "),a("h2",{attrs:{id:"三、生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、生命周期"}},[t._v("#")]),t._v(" 三、生命周期")]),t._v(" "),a("h3",{attrs:{id:"_3-1-react-的生命周期阶段-挂载、更新、卸载、错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-react-的生命周期阶段-挂载、更新、卸载、错误处理"}},[t._v("#")]),t._v(" 3.1 React 的生命周期阶段（挂载、更新、卸载、错误处理）")]),t._v(" "),a("p",[a("img",{attrs:{src:e(327),alt:"image"}}),t._v(" "),a("strong",[t._v("挂载阶段（Mounting）")])]),t._v(" "),a("ul",[a("li",[t._v("constructor()")]),t._v(" "),a("li",[t._v("static getDerivedStateFromProps(props, state)")]),t._v(" "),a("li",[t._v("render()")]),t._v(" "),a("li",[t._v("componentDidMount()")])]),t._v(" "),a("p",[a("strong",[t._v("更新阶段（Updating）")])]),t._v(" "),a("ul",[a("li",[t._v("static getDerivedStateFromProps(props, state)")]),t._v(" "),a("li",[t._v("shouldComponentUpdate(nextProps, nextState)")]),t._v(" "),a("li",[t._v("render()")]),t._v(" "),a("li",[t._v("componentDidUpdate(prevProps, prevState, snapshot)")])]),t._v(" "),a("p",[a("strong",[t._v("卸载阶段（Unmounting）")])]),t._v(" "),a("ul",[a("li",[t._v("componentWillUnmount()")])]),t._v(" "),a("p",[a("strong",[t._v("错误处理阶段（Error Handling）")])]),t._v(" "),a("ul",[a("li",[t._v("static getDerivedStateFromError(error)")]),t._v(" "),a("li",[t._v("componentDidCatch(error, errorInfo)")])]),t._v(" "),a("h3",{attrs:{id:"_3-2-react-性能优化的生命周期及原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-react-性能优化的生命周期及原理"}},[t._v("#")]),t._v(" 3.2 React 性能优化的生命周期及原理")]),t._v(" "),a("p",[t._v("shouldComponentUpdate")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" nextState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("square "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("square"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("React.memo PureComponent 原理是在shouldComponentUpdate 做了浅比较"),a("br"),t._v("\nuseMemo 缓存复杂计算"),a("br"),t._v("\nuseCallback 适合用于React.memo 优化的情况")]),t._v(" "),a("h3",{attrs:{id:"_3-3-state-和-props-触发更新的生命周期区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-state-和-props-触发更新的生命周期区别"}},[t._v("#")]),t._v(" 3.3 state 和 props 触发更新的生命周期区别")]),t._v(" "),a("p",[t._v("state更新流程")]),t._v(" "),a("ul",[a("li",[t._v("更新操作放入更新队列（在 React 18 中会进行自动批处理）")]),t._v(" "),a("li",[t._v("对于类组件，shouldComponentUpdate被触发")]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("componentDidUpdate")])]),t._v(" "),a("p",[t._v("props更新流程")]),t._v(" "),a("ul",[a("li",[t._v("static getDerivedStateFromProps")]),t._v(" "),a("li",[t._v("shouldComponentUpdate")]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("componentDidUpdate")])]),t._v(" "),a("h3",{attrs:{id:"_3-4-react-中发起网络请求的生命周期及原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-react-中发起网络请求的生命周期及原因"}},[t._v("#")]),t._v(" 3.4 React 中发起网络请求的生命周期及原因")]),t._v(" "),a("ul",[a("li",[t._v("componentDidMount")]),t._v(" "),a("li",[t._v("componentDidUpdate 发起网络请求时，需要进行条件判断，以避免无限循环的请求。\n如：根据关键词更新搜索结果时，可以在componentDidUpdate中判断关键词是否变化，如果变化则发起网络请求获取新的搜索结果")])]),t._v(" "),a("h3",{attrs:{id:"_3-5-react-16-中新生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-react-16-中新生命周期"}},[t._v("#")]),t._v(" 3.5 React 16 中新生命周期")]),t._v(" "),a("p",[a("img",{attrs:{src:e(327),alt:"image"}})]),t._v(" "),a("h3",{attrs:{id:"_3-6-react-废弃的生命周期及原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-react-废弃的生命周期及原因"}},[t._v("#")]),t._v(" 3.6 React 废弃的生命周期及原因")]),t._v(" "),a("p",[a("strong",[t._v("componentWillMount废弃的原因")]),a("br"),t._v("\nReact 一直在向异步渲染方向发展。在异步渲染环境下，componentWillMount的执行时机变得模糊。它原本是在组件挂载到 DOM 之前调用，主要用于初始化组件状态或执行一些只需要执行一次的操作。但随着异步渲染的引入，组件可能会被暂停、恢复或者重新排序渲染，这使得componentWillMount的执行顺序和时间难以预测。例如，在服务器端渲染（SSR）与客户端渲染（CSR）结合的场景中，componentWillMount可能会在服务器端和客户端分别执行，这可能导致意外的行为。")]),t._v(" "),a("p",[a("strong",[t._v("componentWillReceiveProps废弃的原因")]),a("br"),t._v("\n容易引发复杂的状态更新逻辑"),a("br"),t._v("\nReact 引入了static getDerivedStateFromProps来替代其部分功能。static getDerivedStateFromProps是一个静态方法，它接收props和state作为参数，并且必须返回一个用于更新state的对象或者null。这种方式使得状态更新更加可控和可预测，避免了componentWillReceiveProps可能出现的副作用和复杂的更新逻辑")]),t._v(" "),a("p",[a("strong",[t._v("componentWillUpdate废弃的原因")]),a("br"),t._v("\n异步渲染导致的不确定性")]),t._v(" "),a("h3",{attrs:{id:"_3-7-react-16-x-中-props-改变后处理的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-react-16-x-中-props-改变后处理的生命周期"}},[t._v("#")]),t._v(" 3.7 React 16.X 中 props 改变后处理的生命周期")]),t._v(" "),a("ul",[a("li",[t._v("static getDerivedStateFromProps(props, state)")]),t._v(" "),a("li",[t._v("shouldComponentUpdate(nextProps, nextState)")]),t._v(" "),a("li",[t._v("render()")]),t._v(" "),a("li",[t._v("componentDidUpdate(prevProps, prevState)")])]),t._v(" "),a("h2",{attrs:{id:"四、组件通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、组件通信"}},[t._v("#")]),t._v(" 四、组件通信")]),t._v(" "),a("h3",{attrs:{id:"_4-1-父子组件的通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-父子组件的通信方式"}},[t._v("#")]),t._v(" 4.1 父子组件的通信方式")]),t._v(" "),a("h3",{attrs:{id:"_4-2-跨级组件的通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-跨级组件的通信方式"}},[t._v("#")]),t._v(" 4.2 跨级组件的通信方式")]),t._v(" "),a("h3",{attrs:{id:"_4-3-非嵌套关系组件的通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-非嵌套关系组件的通信方式"}},[t._v("#")]),t._v(" 4.3 非嵌套关系组件的通信方式")]),t._v(" "),a("h3",{attrs:{id:"_4-4-组件通信的方式总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-组件通信的方式总结"}},[t._v("#")]),t._v(" 4.4 组件通信的方式总结")]),t._v(" "),a("h3",{attrs:{id:"_4-5-解决-props-层级过深的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-解决-props-层级过深的问题"}},[t._v("#")]),t._v(" 4.5 解决 props 层级过深的问题")]),t._v(" "),a("h2",{attrs:{id:"五、路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、路由"}},[t._v("#")]),t._v(" 五、路由")]),t._v(" "),a("h3",{attrs:{id:"_5-1-react-router-的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-react-router-的实现原理"}},[t._v("#")]),t._v(" 5.1 React-Router 的实现原理")]),t._v(" "),a("h3",{attrs:{id:"_5-2-react-router-的路由模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-react-router-的路由模式"}},[t._v("#")]),t._v(" 5.2 React-Router 的路由模式")]),t._v(" "),a("h3",{attrs:{id:"_5-3-react-router4-路由变化时重新渲染同一个组件的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-react-router4-路由变化时重新渲染同一个组件的方法"}},[t._v("#")]),t._v(" 5.3 React-Router4 路由变化时重新渲染同一个组件的方法")]),t._v(" "),a("h3",{attrs:{id:"_5-4-react-router4-的-switch-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-react-router4-的-switch-的作用"}},[t._v("#")]),t._v(" 5.4 React-Router4 的 Switch 的作用")]),t._v(" "),a("h3",{attrs:{id:"_5-5-配置-react-router-实现路由切换的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-配置-react-router-实现路由切换的方法"}},[t._v("#")]),t._v(" 5.5 配置 React-Router 实现路由切换的方法")]),t._v(" "),a("h3",{attrs:{id:"_5-6-react-router-里的-link-标签和-a-标签的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-react-router-里的-link-标签和-a-标签的区别"}},[t._v("#")]),t._v(" 5.6 react-router 里的 Link 标签和 a 标签的区别")]),t._v(" "),a("h3",{attrs:{id:"_5-7-react-router-获取-url-的参数和历史对象的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-react-router-获取-url-的参数和历史对象的方法"}},[t._v("#")]),t._v(" 5.7 React-Router 获取 URL 的参数和历史对象的方法")]),t._v(" "),a("h3",{attrs:{id:"_5-8-react-router-设置重定向的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-8-react-router-设置重定向的方法"}},[t._v("#")]),t._v(" 5.8 React-Router 设置重定向的方法")]),t._v(" "),a("h2",{attrs:{id:"六、redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、redux"}},[t._v("#")]),t._v(" 六、Redux")]),t._v(" "),a("h3",{attrs:{id:"_6-1-对-redux-的理解及解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-对-redux-的理解及解决的问题"}},[t._v("#")]),t._v(" 6.1 对 Redux 的理解及解决的问题")]),t._v(" "),a("h3",{attrs:{id:"_6-2-redux-原理及工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-redux-原理及工作流程"}},[t._v("#")]),t._v(" 6.2 Redux 原理及工作流程")]),t._v(" "),a("h3",{attrs:{id:"_6-3-redux-和-vuex-的区别及共同思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-redux-和-vuex-的区别及共同思想"}},[t._v("#")]),t._v(" 6.3 Redux 和 Vuex 的区别及共同思想")]),t._v(" "),a("h3",{attrs:{id:"_6-4-redux-中异步请求的处理方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-redux-中异步请求的处理方法"}},[t._v("#")]),t._v(" 6.4 Redux 中异步请求的处理方法")]),t._v(" "),a("h3",{attrs:{id:"_6-5-redux-实现属性传递的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-redux-实现属性传递的原理"}},[t._v("#")]),t._v(" 6.5 Redux 实现属性传递的原理")]),t._v(" "),a("h3",{attrs:{id:"_6-6-redux-中间件的定义、参数及作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-redux-中间件的定义、参数及作用"}},[t._v("#")]),t._v(" 6.6 Redux 中间件的定义、参数及作用")]),t._v(" "),a("h3",{attrs:{id:"_6-7-redux-状态管理器和变量挂载到-window-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-redux-状态管理器和变量挂载到-window-的区别"}},[t._v("#")]),t._v(" 6.7 Redux 状态管理器和变量挂载到 window 的区别")]),t._v(" "),a("h3",{attrs:{id:"_6-8-mobox-和-redux-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-mobox-和-redux-的区别"}},[t._v("#")]),t._v(" 6.8 mobox 和 redux 的区别")]),t._v(" "),a("h3",{attrs:{id:"_6-9-redux-中的-connect-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-redux-中的-connect-的作用"}},[t._v("#")]),t._v(" 6.9 Redux 中的 connect 的作用")]),t._v(" "),a("h3",{attrs:{id:"_6-10-redux-请求中间件处理并发的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-10-redux-请求中间件处理并发的方法"}},[t._v("#")]),t._v(" 6.10 Redux 请求中间件处理并发的方法")]),t._v(" "),a("h3",{attrs:{id:"_6-11-redux-中间件获取-store-和-action-的方法及处理方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-11-redux-中间件获取-store-和-action-的方法及处理方式"}},[t._v("#")]),t._v(" 6.11 Redux 中间件获取 store 和 action 的方法及处理方式")]),t._v(" "),a("h2",{attrs:{id:"七、hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、hooks"}},[t._v("#")]),t._v(" 七、Hooks")]),t._v(" "),a("h3",{attrs:{id:"_7-1-对-react-hook-的理解及实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-对-react-hook-的理解及实现原理"}},[t._v("#")]),t._v(" 7.1 对 React Hook 的理解及实现原理")]),t._v(" "),a("h3",{attrs:{id:"_7-2-为什么-usestate-要使用数组而不是对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-为什么-usestate-要使用数组而不是对象"}},[t._v("#")]),t._v(" 7.2 为什么 useState 要使用数组而不是对象")]),t._v(" "),a("h3",{attrs:{id:"_7-3-react-hooks-解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-react-hooks-解决的问题"}},[t._v("#")]),t._v(" 7.3 React Hooks 解决的问题")]),t._v(" "),a("h3",{attrs:{id:"_7-4-useeffect-与-uselayouteffect-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-useeffect-与-uselayouteffect-的区别"}},[t._v("#")]),t._v(" 7.4 useEffect 与 useLayoutEffect 的区别")]),t._v(" "),a("h3",{attrs:{id:"_7-5-react-hook-的使用限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-react-hook-的使用限制"}},[t._v("#")]),t._v(" 7.5 React Hook 的使用限制")]),t._v(" "),a("h3",{attrs:{id:"_7-6-react-hooks-在开发中需要注意的问题及原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-react-hooks-在开发中需要注意的问题及原因"}},[t._v("#")]),t._v(" 7.6 React Hooks 在开发中需要注意的问题及原因")]),t._v(" "),a("h3",{attrs:{id:"_7-7-react-hooks-和生命周期的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-7-react-hooks-和生命周期的关系"}},[t._v("#")]),t._v(" 7.7 React Hooks 和生命周期的关系")]),t._v(" "),a("h2",{attrs:{id:"八、虚拟-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、虚拟-dom"}},[t._v("#")]),t._v(" 八、虚拟 DOM")]),t._v(" "),a("h3",{attrs:{id:"_8-1-对虚拟-dom-的理解、作用及本身的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-对虚拟-dom-的理解、作用及本身的定义"}},[t._v("#")]),t._v(" 8.1 对虚拟 DOM 的理解、作用及本身的定义")]),t._v(" "),a("h3",{attrs:{id:"_8-2-react-diff-算法的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-react-diff-算法的原理"}},[t._v("#")]),t._v(" 8.2 React diff 算法的原理")]),t._v(" "),a("h3",{attrs:{id:"_8-3-react-key-的作用及解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-react-key-的作用及解决的问题"}},[t._v("#")]),t._v(" 8.3 React key 的作用及解决的问题")]),t._v(" "),a("h3",{attrs:{id:"_8-4-虚拟-dom-与直接操作原生-dom-的效率比较及原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-虚拟-dom-与直接操作原生-dom-的效率比较及原因"}},[t._v("#")]),t._v(" 8.4 虚拟 DOM 与直接操作原生 DOM 的效率比较及原因")]),t._v(" "),a("h3",{attrs:{id:"_8-5-react-与-vue-的-diff-算法的不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-react-与-vue-的-diff-算法的不同"}},[t._v("#")]),t._v(" 8.5 React 与 Vue 的 diff 算法的不同")]),t._v(" "),a("h2",{attrs:{id:"九、其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、其他"}},[t._v("#")]),t._v(" 九、其他")]),t._v(" "),a("h3",{attrs:{id:"_9-1-对-react-和-vue-的理解及异同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-对-react-和-vue-的理解及异同"}},[t._v("#")]),t._v(" 9.1 对 React 和 Vue 的理解及异同")]),t._v(" "),a("h3",{attrs:{id:"_9-2-react-中的遍历方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-react-中的遍历方法"}},[t._v("#")]),t._v(" 9.2 React 中的遍历方法")]),t._v(" "),a("h3",{attrs:{id:"_9-3-对-react-ssr-的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-对-react-ssr-的理解"}},[t._v("#")]),t._v(" 9.3 对 React SSR 的理解")]),t._v(" "),a("h3",{attrs:{id:"_9-4-react-要用-jsx-的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-react-要用-jsx-的原因"}},[t._v("#")]),t._v(" 9.4 React 要用 JSX 的原因")]),t._v(" "),a("h3",{attrs:{id:"_9-5-react-最新版本解决的问题及增加的内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-react-最新版本解决的问题及增加的内容"}},[t._v("#")]),t._v(" 9.5 React 最新版本解决的问题及增加的内容")]),t._v(" "),a("h3",{attrs:{id:"_9-6-react-数据持久化的实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-6-react-数据持久化的实践"}},[t._v("#")]),t._v(" 9.6 React 数据持久化的实践")]),t._v(" "),a("h3",{attrs:{id:"_9-7-react-的设计思路及理念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-7-react-的设计思路及理念"}},[t._v("#")]),t._v(" 9.7 React 的设计思路及理念")]),t._v(" "),a("h3",{attrs:{id:"_9-8-react-中-props-children-和-react-children-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-8-react-中-props-children-和-react-children-的区别"}},[t._v("#")]),t._v(" 9.8 React 中 props.children 和 React.Children 的区别")]),t._v(" "),a("h3",{attrs:{id:"_9-9-react-的状态提升及使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-9-react-的状态提升及使用场景"}},[t._v("#")]),t._v(" 9.9 React 的状态提升及使用场景")]),t._v(" "),a("h3",{attrs:{id:"_9-10-同时引用-react-js、react-dom-js-和-babel-js-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-10-同时引用-react-js、react-dom-js-和-babel-js-的作用"}},[t._v("#")]),t._v(" 9.10 同时引用 react.js、react-dom.js 和 babel.js 的作用")]),t._v(" "),a("h3",{attrs:{id:"_9-11-react-children-map-和-js-的-map-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-11-react-children-map-和-js-的-map-的区别"}},[t._v("#")]),t._v(" 9.11 React.Children.map 和 js 的 map 的区别")]),t._v(" "),a("h3",{attrs:{id:"_9-12-react-组件命名的推荐方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-12-react-组件命名的推荐方式"}},[t._v("#")]),t._v(" 9.12 React 组件命名的推荐方式")]),t._v(" "),a("h3",{attrs:{id:"_9-13-react-实现全局-dialog-的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-13-react-实现全局-dialog-的方法"}},[t._v("#")]),t._v(" 9.13 React 实现全局 dialog 的方法")]),t._v(" "),a("h3",{attrs:{id:"_9-14-react-页面重新加载时保留数据的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-14-react-页面重新加载时保留数据的方法"}},[t._v("#")]),t._v(" 9.14 React 页面重新加载时保留数据的方法")]),t._v(" "),a("h3",{attrs:{id:"_9-15-react-中使用-async-await-的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-15-react-中使用-async-await-的方法"}},[t._v("#")]),t._v(" 9.15 React 中使用 async/await 的方法")]),t._v(" "),a("h3",{attrs:{id:"_9-16-使用-typescript-写-react-应用的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-16-使用-typescript-写-react-应用的方法"}},[t._v("#")]),t._v(" 9.16 使用 TypeScript 写 React 应用的方法")]),t._v(" "),a("h3",{attrs:{id:"_9-17-react-中-constructor-和-getinitialstate-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-17-react-中-constructor-和-getinitialstate-的区别"}},[t._v("#")]),t._v(" 9.17 React 中 constructor 和 getInitialState 的区别")]),t._v(" "),a("h3",{attrs:{id:"_9-18-react-的严格模式的使用方法及用处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-18-react-的严格模式的使用方法及用处"}},[t._v("#")]),t._v(" 9.18 React 的严格模式的使用方法及用处")]),t._v(" "),a("h3",{attrs:{id:"_9-19-为什么使用-jsx-的组件中没看到使用-react-却需要引入-react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-19-为什么使用-jsx-的组件中没看到使用-react-却需要引入-react"}},[t._v("#")]),t._v(" 9.19 为什么使用 jsx 的组件中没看到使用 react 却需要引入 react")]),t._v(" "),a("h3",{attrs:{id:"_9-20-hoc-相比-mixins-的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-20-hoc-相比-mixins-的优点"}},[t._v("#")]),t._v(" 9.20 HOC 相比 mixins 的优点")]),t._v(" "),a("h3",{attrs:{id:"_9-21-react-中的高阶组件运用的设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-21-react-中的高阶组件运用的设计模式"}},[t._v("#")]),t._v(" 9.21 React 中的高阶组件运用的设计模式")])])}),[],!1,null,null,null);a.default=s.exports}}]);